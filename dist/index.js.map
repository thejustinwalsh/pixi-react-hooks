{"version":3,"sources":["../src/useAssets.ts","../src/useAssetBundle.ts","../src/useAssetManifest.ts"],"sourcesContent":["import {useEffect} from 'react';\nimport {useAssetState} from './hooks/useAssetState';\nimport {isLoaded, load, resolve} from './utils';\n\nimport type {UnresolvedAsset} from 'pixi.js';\nimport type {AssetState, AssetUrl} from './types';\n\nexport function useAssets<T>(urls: string | UnresolvedAsset): AssetState<T | undefined>;\nexport function useAssets<T>(urls: string[] | UnresolvedAsset[]): AssetState<Record<string, T>>;\n\nexport function useAssets<T>(urls: AssetUrl) {\n  const [state, setState, thenable] = useAssetState<T, AssetUrl>(urls, isLoaded, load, resolve);\n\n  useEffect(() => {\n    thenable\n      ?.then(data => setState({status: 'loaded', isLoaded: true, error: null, data}))\n      .catch(error => setState({status: 'error', isLoaded: false, error, data: null}));\n  }, [setState, thenable]);\n\n  return state;\n}\n","import {useEffect} from 'react';\nimport {useAssetState} from './hooks/useAssetState';\nimport {isBundleLoaded, loadBundle, resolveBundle} from './utils';\n\nimport type {ResolvedAsset} from 'pixi.js';\nimport type {AssetState, AssetBundle} from './types';\n\nexport function useAssetBundle(bundles: string): AssetState<Record<string, ResolvedAsset>>;\nexport function useAssetBundle(\n  bundles: string[],\n): AssetState<Record<string, Record<string, ResolvedAsset>>>;\n\nexport function useAssetBundle(bundles: string | string[]) {\n  const [state, setState, thenable] = useAssetState<AssetBundle, string | string[]>(\n    bundles,\n    isBundleLoaded,\n    loadBundle,\n    resolveBundle,\n  );\n\n  useEffect(() => {\n    thenable\n      ?.then(data => setState({status: 'loaded', isLoaded: true, error: null, data}))\n      .catch(error => setState({status: 'error', isLoaded: false, error, data: null}));\n  }, [setState, thenable]);\n\n  return state;\n}\n","import {Assets, AssetsManifest} from 'pixi.js';\nimport {useEffect, useState} from 'react';\n\ntype AssetManifestState = {\n  isLoaded: boolean;\n  thenable: Promise<void>;\n};\n\nexport function useAssetManifest(\n  manifest: AssetsManifest,\n  bundles: string[] = [],\n  options: Omit<Parameters<typeof Assets.init>[0], 'manifest'> = {},\n) {\n  const [{isLoaded, thenable}, setState] = useState<AssetManifestState>(() => ({\n    isLoaded: false,\n    thenable: Assets.init({\n      ...options,\n      manifest,\n    }).then(() => {\n      Assets.backgroundLoadBundle(\n        bundles.length > 0 ? bundles : manifest.bundles.map(bundle => bundle.name),\n      );\n    }),\n  }));\n\n  useEffect(() => {\n    thenable.then(() => setState(s => ({...s, isLoaded: true})));\n  }, [thenable]);\n\n  return {isLoaded};\n}\n"],"mappings":";;;;;;;;;;;AAAA,SAAQ,iBAAgB;AAUjB,SAAS,UAAa,MAAgB;AAC3C,QAAM,CAAC,OAAO,UAAU,QAAQ,IAAI,cAA2B,MAAM,UAAU,MAAM,OAAO;AAE5F,YAAU,MAAM;AACd,cACI,KAAK,UAAQ,SAAS,EAAC,QAAQ,UAAU,UAAU,MAAM,OAAO,MAAM,KAAI,CAAC,CAAC,EAC7E,MAAM,WAAS,SAAS,EAAC,QAAQ,SAAS,UAAU,OAAO,OAAO,MAAM,KAAI,CAAC,CAAC;AAAA,EACnF,GAAG,CAAC,UAAU,QAAQ,CAAC;AAEvB,SAAO;AACT;;;ACpBA,SAAQ,aAAAA,kBAAgB;AAYjB,SAAS,eAAe,SAA4B;AACzD,QAAM,CAAC,OAAO,UAAU,QAAQ,IAAI;AAAA,IAClC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,EAAAC,WAAU,MAAM;AACd,cACI,KAAK,UAAQ,SAAS,EAAC,QAAQ,UAAU,UAAU,MAAM,OAAO,MAAM,KAAI,CAAC,CAAC,EAC7E,MAAM,WAAS,SAAS,EAAC,QAAQ,SAAS,UAAU,OAAO,OAAO,MAAM,KAAI,CAAC,CAAC;AAAA,EACnF,GAAG,CAAC,UAAU,QAAQ,CAAC;AAEvB,SAAO;AACT;;;AC3BA,SAAQ,cAA6B;AACrC,SAAQ,aAAAC,YAAW,gBAAe;AAO3B,SAAS,iBACd,UACA,UAAoB,CAAC,GACrB,UAA+D,CAAC,GAChE;AACA,QAAM,CAAC,EAAC,UAAAC,WAAU,SAAQ,GAAG,QAAQ,IAAI,SAA6B,OAAO;AAAA,IAC3E,UAAU;AAAA,IACV,UAAU,OAAO,KAAK;AAAA,MACpB,GAAG;AAAA,MACH;AAAA,IACF,CAAC,EAAE,KAAK,MAAM;AACZ,aAAO;AAAA,QACL,QAAQ,SAAS,IAAI,UAAU,SAAS,QAAQ,IAAI,YAAU,OAAO,IAAI;AAAA,MAC3E;AAAA,IACF,CAAC;AAAA,EACH,EAAE;AAEF,EAAAD,WAAU,MAAM;AACd,aAAS,KAAK,MAAM,SAAS,QAAM,EAAC,GAAG,GAAG,UAAU,KAAI,EAAE,CAAC;AAAA,EAC7D,GAAG,CAAC,QAAQ,CAAC;AAEb,SAAO,EAAC,UAAAC,UAAQ;AAClB;","names":["useEffect","useEffect","useEffect","isLoaded"]}