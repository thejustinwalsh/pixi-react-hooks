{"version":3,"sources":["../src/utils/index.ts","../src/hooks/useAssetState.ts","../src/hooks/useAssetCache.ts"],"sourcesContent":["import {Assets} from 'pixi.js';\n\nimport type {UnresolvedAsset} from 'pixi.js';\n\nexport const key = (url: string | UnresolvedAsset) =>\n  typeof url === 'string' ? url : (url.alias ?? url.src ?? '')?.toString();\n\nexport const createKey = (urls: string | UnresolvedAsset | string[] | UnresolvedAsset[]) =>\n  new Set(Array.isArray(urls) ? urls.map(key) : [key(urls)]);\n\nexport const didKeyChange = (\n  urls: string | UnresolvedAsset | string[] | UnresolvedAsset[],\n  keys: Set<string>,\n) => (Array.isArray(urls) ? !urls.every(url => keys.has(key(url))) : !keys.has(key(urls)));\n\nexport const isLoaded = (urls: string | UnresolvedAsset | string[] | UnresolvedAsset[]) =>\n  Array.isArray(urls) ? urls.every(url => Assets.cache.has(key(url))) : Assets.cache.has(key(urls));\n\nexport const isBundleLoaded = (bundles: string | string[]) =>\n  Array.isArray(bundles)\n    ? bundles.every(bundle => Assets.resolver.hasBundle(bundle))\n    : Assets.resolver.hasBundle(bundles);\n\nexport const load = (urls: string | UnresolvedAsset | string[] | UnresolvedAsset[]) =>\n  Assets.load(urls);\n\nexport const loadBundle = <T = any>(bundles: string | string[]): Promise<T> =>\n  Assets.loadBundle(bundles);\n\nexport const resolve = <T = any>(urls: string | UnresolvedAsset | string[] | UnresolvedAsset[]) =>\n  Array.isArray(urls)\n    ? urls.reduce((acc, url) => {\n        const k = key(url);\n        if (Assets.cache.has(k)) acc[k] = Assets.cache.get(k);\n        return acc;\n      }, {} as Record<string, T>)\n    : Assets.cache.get(key(urls));\n\nexport const resolveBundle = <T = any>(bundles: string | string[]) =>\n  Assets.resolver.resolveBundle(bundles) as T;\n","import React, {useMemo} from 'react';\nimport {useEffect, useState} from 'react';\nimport {didKeyChange, createKey} from '../utils';\nimport {loadFromCache, usePromiseCache} from './useAssetCache';\n\nimport type {\n  AssetState,\n  HookState,\n  PendingAssetState,\n  LoadedAssetState,\n  ErrorAssetState,\n  AssetUrl,\n} from '../types';\n\ntype LoadedAssetStateReturn<T> = readonly [\n  LoadedAssetState<T>,\n  React.Dispatch<React.SetStateAction<AssetState<T>>>,\n  Promise<T> | null,\n];\n\ntype PendingAssetStateReturn<T> = readonly [\n  PendingAssetState,\n  React.Dispatch<React.SetStateAction<AssetState<T>>>,\n  Promise<T>,\n];\n\ntype ErrorAssetStateReturn<T> = readonly [\n  ErrorAssetState,\n  React.Dispatch<React.SetStateAction<AssetState<T>>>,\n  Promise<T>,\n];\n\ntype AssetStateReturn<T> =\n  | LoadedAssetStateReturn<T>\n  | PendingAssetStateReturn<T>\n  | ErrorAssetStateReturn<T>;\n\nexport function useAssetState<T, P extends AssetUrl>(\n  urls: P,\n  isLoaded: (urls: P) => boolean,\n  load: <T>(urls: P) => Promise<T>,\n  resolve: <T>(urls: P) => T,\n): AssetStateReturn<T> {\n  const key = useMemo(() => createKey(urls), [urls]);\n  const cache = usePromiseCache<T>();\n  const [assetState, setAssetState] = useState<AssetState<T>>(() => {\n    const loaded = isLoaded(urls);\n    return loaded\n      ? {\n          status: 'loaded',\n          isLoaded: true,\n          error: null,\n          data: resolve(urls),\n        }\n      : {\n          status: 'pending',\n          isLoaded: false,\n          error: null,\n          data: null,\n        };\n  });\n\n  const [state, setState] = useState<HookState<T>>(() => ({\n    thenable: !assetState.isLoaded ? loadFromCache(cache, key, () => load(urls)) : null,\n    key,\n  }));\n\n  useEffect(() => {\n    if (didKeyChange(urls, state.key)) {\n      if (isLoaded(urls)) {\n        setAssetState({status: 'loaded', isLoaded: true, error: null, data: resolve(urls)});\n        setState(state => ({...state, key}));\n      } else {\n        setState({thenable: loadFromCache(cache, key, () => load(urls)), key});\n        setAssetState({status: 'pending', isLoaded: false, error: null, data: null});\n      }\n    }\n  }, [cache, isLoaded, key, load, resolve, state.key, urls]);\n\n  if (assetState.status === 'error') {\n    return [assetState, setAssetState, state.thenable!] as const;\n  }\n\n  if (assetState.status === 'pending') {\n    return [assetState, setAssetState, state.thenable!] as const;\n  }\n\n  return [assetState, setAssetState, state.thenable!] as const;\n}\n","import React, {useCallback, useTransition} from 'react';\n\nconst getCacheForType = <T>(resourceType: () => T) =>\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.A.getCacheForType(\n    resourceType,\n  );\n\nconst useCacheRefresh = () =>\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.H.useCacheRefresh();\n\nconst createPromiseCache = <T>() => new Map<string, Promise<T>>();\n\n// TODO: Cache should be a map of keys to promises, and their destination cache with the the asset keys they resolve to\n// TODO: We can allow the user to optionally purge the entire cache or the cache for a specific key\n// TODO: We can not selectively replace specific keys with the public api when refreshing, but we can control the backing cache\n// TODO: When you hit an error boundary for an asset, you may want to try loading the asset again, and if that fails, you may want to purge the cache\n\nexport function loadFromCache<T>(\n  cache: Map<string, Promise<T>>,\n  key: Set<string>,\n  load: () => Promise<T>,\n) {\n  const cacheKey = Array.from(key).join('|');\n  let promise = cache.get(cacheKey);\n  if (!promise) {\n    promise = load();\n    cache.set(cacheKey, promise);\n  }\n  return promise;\n}\n\nexport function usePromiseCache<T>() {\n  return getCacheForType(createPromiseCache<T>);\n}\n\n// TODO: Store keys along with the promises so we can purge the Asset cache when we refresh or clear the cache\nexport function useAssetCache() {\n  //const cache = getPromiseCache();\n  const cacheRefresh = useCacheRefresh();\n  const [isPending, startTransition] = useTransition();\n\n  const refresh = useCallback(\n    (keys?: string[]) => {\n      // When we purge we need to reset the cache for the keys that are being purged\n      startTransition(() => {\n        cacheRefresh();\n      });\n    },\n    [cacheRefresh],\n  );\n\n  const clear = useCallback(\n    (all: boolean = false) => {\n      // TODO: Walk everything in current promise cache and clear it\n      // TODO: If all is set, reset the entire backing cache instead\n      startTransition(() => {\n        cacheRefresh();\n      });\n    },\n    [cacheRefresh],\n  );\n\n  return [isPending, refresh, clear] as const;\n}\n"],"mappings":"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","names":["key","load","isLoaded","load","resolve","key","state"]}